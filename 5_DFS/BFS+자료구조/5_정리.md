- list(map(int, input())) 실행 후 123등의 연속된 숫자 입력 -> [1, 2, 3]의 리스트로 리턴
- 2자리 이상의 숫자가 담긴 map객체를 list함수의 인자로 입력할 시 분리시켜 주는 듯?

# 자료구조 기초
- 자료구조: 데이터를 표현하고 관리하기 위한 구조
    - 오버플로: 자료구조가 수용할 수 있는 데이터의 크기가 꽉 찬 상태에서 삽입연산 수행할 때 발생
    - 언더플로: 자료구조에 데이터가 전혀 들어있지 않은 상태에서 삭제연산 수행시 발생

## 재귀함수
- 자기 자신을 호출하는 함수
- 재귀함수가 끝나는 종료조건을 반드시 명시해야한다. if문을 통해 조건을 부여
- 재귀함수의 수행은 스택 자료구조를 이용(내부적으로 스택 자료구조와 동일)

## 그래프
### 그래프의 표현 방식
1. 인접 행렬: 2차원 배열로 그래프의 연결관계 표현(파이썬에서는 배열을 리스트로 표현 가능)
INF = 987654321
- 예시
    graph = [
        [0, 7, 5],
        [7, 0, INF],
        [5, INF, 0]
    ]
    print(graph)
    > [[0, 7, 5], [7, 0, 987654321], [5, 987654321, 0]]
2. 인접 리스트: 리스트로 그래프의 연결 관계를 표현하는 방식(파이썬에서 연결리스트 또한 단순히 2차원 리스트로 표현 가능)
- 각 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
- 예시
    graph = [[] for _ in range(3)]

    graph[0].append((1,7)) # 노드0에 연결된 정보 저장(노드, 거리)
    graph[0].append((2,5))

    graph[1].append((0, 7)) # 노드1에 연결된 정보 저장(노드, 거리)

    graph[2].append((0,5)) # 노드2에 연결된 정보 저장(노드, 거리)

    print(graph)
    > [[(1,7),(2,5)],[(0,7)],[(0,5)]]

### 메모리 차원에서 살펴보기
1. 인접 행렬 - 모든 관계 저장하므로 노드 개수 많을수록 메모리 낭비, 정보 얻는 속도 빠름
예) graph[1][7]로 노드 1과 7이 연결되어있는지 쉽게 파악 가능
2. 인접 리스트 - 연결된 정보만 저장, 메모리 효율적. 그러나 연결정보 파악위해 하나씩 확인해야 하므로 정보 얻는 속도가 느림
예) 노드 1에 대한 인접 리스트를 앞에서부터 차례대로 확인해야 함.

## DFS와 BFS
- 추후 추가 예정...